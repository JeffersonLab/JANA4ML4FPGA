import argparse
import subprocess
import shlex
import os
import sys
from collections import OrderedDict
from os import path
from datetime import datetime
import re
from tempfile import mkstemp
from shutil import move
from os import remove
import platform

# Constants
MAMBA_ENV_NAME = 'ml4fpga'
ENV_NAME_TOP_DIR = 'ML4FPGA_TOP_DIR'


# Template content
def get_mamba_env_content(cfg):
    return f"""
name: {cfg.mamba_env_name}
channels:
  - conda-forge
  - defaults
dependencies:
  - python=3.10
  - gcc
  - cmake
  - xerces-c
  - xorg-libxmu
  - clhep
  - git
  - git-lfs
  - nodejs
  - boost
  - ipywidgets
  - zstd
  - hepmc3
  - pip
  - pip:
    - click
    - appdirs
    - edpm
    - uproot
    - awkward-numba
    - numpy
    - pandas
    - matplotlib
    - seaborn
    - plotly
    - pyjet
    - pyjano
    - wget
    - edpm
variables:
  PYTHONHTTPSVERIFY: "0"
"""

def get_template_setup_mamba(install_info):
    return f"""
set -e
source {install_info.mamba_dir}/etc/profile.d/mamba.sh
    
export PYTHONHTTPSVERIFY=0
export OPENSSL_CONF={install_info.script_openssl_cnf}
mamba config --set ssl_verify false
mamba update -n base -y mamba
mamba create -y --name {install_info.mamba_env_name} python=3.10
mamba activate {install_info.mamba_env_name}

edpm --top-dir={install_info.top_dir}

edpm config global cxx_standard=17

# so edpm generated the right environment
export ROOT_INSTALLED_BY_MAMBA=1

# Set root which we installed before
edpm set root {install_info.mamba_env_dir}
edpm set clhep {install_info.mamba_env_dir}
edpm set hepmc3 {install_info.mamba_env_dir}
"""


def get_template_build_soft(cfg):
    return f"""
set -e
export EDPM_DATA_PATH={cfg.top_dir}
source {cfg.mamba_dir}/etc/profile.d/mamba.sh
mamba activate {cfg.mamba_env_name}
echo ""
echo "================================"
echo "  B U I L D    P A C K A G E S  "
echo "================================"
echo ""
edpm add jana2
edpm config jana2 branch=v2.4.0
edpm config jana2 cmake_flags="-DUSE_ROOT=On -DUSE_PYTHON=Off -DUSE_PODIO=On"
edpm install jana2
edpm install jana4ml4fpga
"""


def get_template_user_sh(install_info):
    return f"""
export {install_info.env_name_top_dir}={install_info.top_dir}

# Start mamba environment
source {install_info.top_dir}/micromamba/etc/profile.d/mamba.sh
mamba activate {install_info.mamba_env_name}

# The path where edpm stores its JSon database and creates env files
export EDPM_DATA_PATH={install_info.top_dir}

# This tells EDPM not to generate source thisroot.sh
export ROOT_INSTALLED_BY_MAMBA=1

# This is unfortunate requirement for JLab certificates
export PYTHONHTTPSVERIFY=0
export OPENSSL_CONF={install_info.script_openssl_cnf}

# source environment generated by EDPM
# means ROOT and others
source $EDPM_DATA_PATH/env.sh
"""


def get_template_user_csh(install_info):
    return f"""
setenv {install_info.env_name_top_dir} {install_info.top_dir}

# Start mamba environment
source {install_info.top_dir}/micromamba/etc/profile.d/mamba.csh
mamba activate {install_info.mamba_env_name}

# The path where edpm stores its JSon database and creates env files
setenv EDPM_DATA_PATH {install_info.top_dir}

# This tells EDPM not to generate source thisroot.sh
setenv ROOT_INSTALLED_BY_MAMBA 1

# This is unfortunate requirement for JLab certificates
setenv PYTHONHTTPSVERIFY 0
setenv OPENSSL_CONF {install_info.script_openssl_cnf}

# source environment generated by EDPM
# means ROOT and others
source $EDPM_DATA_PATH/env.csh
"""

class InstallConfig:
    """Class that holds all installation information and paths"""

    # Script and directory names (moved from global constants)
    MAMBA_ENV_NAME = MAMBA_ENV_NAME
    SCRIPT_NAME_SETUP_MAMBA = "setup_mamba.sh"
    SCRIPT_NAME_BUILD_SOFT = "build_software.sh"
    SCRIPT_NAME_ENV_BASH = "setup_env.sh"
    SCRIPT_NAME_ENV_CSH = "setup_env.csh"
    SCRIPT_NAME_MAMBA_ENV = "environment.yaml"
    INSTALL_SCRIPTS_DIR_NAME = "install_scripts"

    def __init__(self):
        self.this_script_dir = ""
        self.top_dir = ""
        self.mamba_dir = ""
        self.mamba_env_name = ""
        self.mamba_env_dir = ""
        self.scripts_dir = ""
        self.script_setup_mamba = ""
        self.script_build_soft = ""
        self.script_openssl_cnf = ""
        self.script_mamba_env = ""
        self.env_name_top_dir = ENV_NAME_TOP_DIR

    @staticmethod
    def create(install_path=None) -> 'InstallConfig':
        """This method setups all main variables

        Args:
            install_path: Optional path where to install. If None, uses current directory
        """
        # The directory in which this script is located
        this_script_dir = path.dirname(path.abspath(__file__))

        # Use specified install path, or current working directory if not provided
        if install_path:
            top_dir = path.abspath(install_path)
        else:
            top_dir = os.getcwd()

        # Set environment variable
        os.environ[ENV_NAME_TOP_DIR] = top_dir

        # Create result
        result = InstallConfig()
        result.this_script_dir = this_script_dir
        result.top_dir = top_dir
        result.mamba_dir = path.join(top_dir, 'micromamba')
        result.mamba_env_name = InstallConfig.MAMBA_ENV_NAME
        result.mamba_env_dir = path.join(result.mamba_dir, 'envs', result.mamba_env_name)
        result.scripts_dir = path.join(top_dir, InstallConfig.INSTALL_SCRIPTS_DIR_NAME)
        result.script_setup_mamba = path.join(top_dir, InstallConfig.INSTALL_SCRIPTS_DIR_NAME, InstallConfig.SCRIPT_NAME_SETUP_MAMBA)
        result.script_build_soft = path.join(top_dir, InstallConfig.INSTALL_SCRIPTS_DIR_NAME, InstallConfig.SCRIPT_NAME_BUILD_SOFT)
        result.script_mamba_env = path.join(top_dir, InstallConfig.INSTALL_SCRIPTS_DIR_NAME, InstallConfig.SCRIPT_NAME_MAMBA_ENV)
        result.script_openssl_cnf = path.join(top_dir, InstallConfig.INSTALL_SCRIPTS_DIR_NAME, 'openssl.cnf')

        return result

    def asdict(self):
        """Convert instance attributes to dictionary"""
        return {key: value for key, value in self.__dict__.items()
                if not key.startswith('__') and not callable(key)}

    def print_self(self):
        """Print installation information"""
        print("Created install info:")
        print("  -this_script_dir:", self.this_script_dir)
        print("  -top_dir:", self.top_dir)
        print("  -mamba_dir:  ", self.mamba_dir)
        print("  -mamba_env_name: ", self.mamba_env_name)
        print("  -mamba_env_dir: ", self.mamba_env_dir)
        print("  -scripts_dir: ", self.scripts_dir)
        print("  -script_mamba_env: ", self.script_mamba_env)
        print("  -script_setup_mamba: ", self.script_setup_mamba)
        print("  -script_build_soft: ", self.script_build_soft)
        print("  -script_openssl_cnf: ", self.script_openssl_cnf)




def get_mambarc_content():
    return """
channel_priority: strict
channels:
  - conda-forge
  - defaults
"""


def get_openssl_cnf_content():
    return """
openssl_conf = openssl_init

[openssl_init]
ssl_conf = ssl_sect

[ssl_sect]
system_default = system_default_sect

[system_default_sect]
Options = UnsafeLegacyRenegotiation
"""




def run(command, cwd=None, shell=False, exit_on_error=True, silent=False):
    """Wrapper around subprocess.Popen that returns:

    :return retval, start_time, end_time, lines
    """
    if isinstance(command, str):
        command = shlex.split(command)

    # Pretty header for the command
    if not silent:
        print('=' * 20)
        print("RUN: " + " ".join(command))
        print('=' * 20)

    # Record the start time
    start_time = datetime.now()
    lines = []

    # stderr is redirected to STDOUT because otherwise it needs special handling
    # we don't need it and we don't care as C++ warnings generate too much stderr
    # which makes it pretty much like stdout
    process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, cwd=cwd, shell=shell)
    while True:
        line = process.stdout.readline().decode('latin-1').replace('\r', '\n')

        if process.poll() is not None and line == '':
            break
        if line:
            if line.endswith('\n'):
                line = line[:-1]
            if not silent:
                try:
                    # This try block is to fix
                    # TypeError: endswith first arg must be bytes or a tuple of bytes, not str
                    # which may happen when building root under docker
                    print(line)
                except:
                    print(str(line.encode('utf-8')))
                lines.append(line)

    # Get return value and finishing time
    retval = process.poll()
    end_time = datetime.now()
    if not silent:
        print("------------------------------------------")
        print("RUN DONE. RETVAL: {} \n\n".format(retval))

    if retval != 0:
        if not silent:
            print("ERROR. Retval is not 0. Plese, look at the logs\n")
        if exit_on_error:
            exit(1)

    return retval, start_time, end_time, lines


def make_file(file_path, content):
    """Create a file with given content"""
    # Ensure the directory exists before creating the file
    os.makedirs(os.path.dirname(file_path), exist_ok=True)

    with open(file_path, 'w') as f:
        f.write(content)


def is_mamba_env_exist(install_info):
    """Check if mamba environment exists"""
    mamba_env_exe = path.join(install_info.mamba_dir, 'bin', 'mamba-env')

    # Check if the executable exists before running it
    if not os.path.exists(mamba_env_exe):
        return None

    _, _, _, lines = run(f'{mamba_env_exe} list', silent=True)

    # mamba env list give something like:
    # # mamba environments:
    #  base   <path>
    #  esc  * <path>
    pattern = re.compile(f"^{install_info.mamba_env_name}\\s")
    for line in lines:
        if pattern.match(line):
            return line
    return None


def step0_generate_scripts(install_info):
    """Generate all bash scripts"""
    print("\n")
    print("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")
    print(" S T E P  0   G E N E R A T E   S C R I P T S ")
    print("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")

    print("Creating scripts directory")
    os.makedirs(install_info.scripts_dir, exist_ok=True)

    print("Generating scripts")
    make_file(path.join(install_info.top_dir, InstallConfig.SCRIPT_NAME_ENV_BASH), get_template_user_sh(install_info))

    make_file(path.join(install_info.top_dir, InstallConfig.SCRIPT_NAME_ENV_CSH), get_template_user_csh(install_info))

    make_file(install_info.script_openssl_cnf, get_openssl_cnf_content())

    make_file(install_info.script_setup_mamba, get_template_setup_mamba(install_info))

    make_file(install_info.script_build_soft, get_template_build_soft(install_info))

    make_file(install_info.script_mamba_env, get_mamba_env_content())


def step1_install_micromamba(config):
    print("\n")
    print("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")
    print(" S T E P  1   I N S T A L L   M I C R O M A M B A")
    print("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")

    """Install micromamba"""
    if os.path.isdir(config.mamba_dir):
        print(f"Path '{config.mamba_dir}' already exists. Skipping installation step.")
        return

    # Make sure top directory exists
    os.makedirs(config.top_dir, exist_ok=True)

    # Map system name to the format used in Miniforge URL
    system_name = platform.system()
    if system_name == 'Darwin':
        system_name = 'MacOSX'
    elif system_name == 'Windows':
        # Miniforge has a different naming convention for Windows
        arch = 'x86_64' if platform.machine() == 'AMD64' else platform.machine()
        mamba_install_sh_link = f'https://github.com/conda-forge/miniforge/releases/latest/download/Miniforge3-Windows-{arch}.exe'
    else:
        # For Linux and other systems, use the general format
        mamba_install_sh_link = f'https://github.com/conda-forge/miniforge/releases/latest/download/Miniforge3-{system_name}-{platform.machine()}.sh'


    print(f"Downloading micromamba from {mamba_install_sh_link} ...")

    # Download to the installation directory
    installer_path = os.path.join(config.top_dir, "micromamba.sh")
    run(f'curl -L {mamba_install_sh_link} -o {installer_path}', cwd=config.top_dir)


    # Run the installer from the installation directory
    run(f"bash {installer_path} -b -p {config.mamba_dir}", cwd=config.top_dir)

    # Remove the installer
    try:
        os.remove(installer_path)
    except:
        print(f"Warning: Could not remove installer at {installer_path}")

    # Verify the installation directory exists
    if not os.path.isdir(config.mamba_dir):
        print(f"Error: micromamba installation failed to create directory at {config.mamba_dir}")
        sys.exit(1)

    # Create .condarc file in the micromamba installation directory
    condarc_path = os.path.join(config.mamba_dir, '.condarc')
    print(f"Creating .condarc at {condarc_path}")
    make_file(condarc_path, get_mambarc_content())


def step2_setup_mamba(install_info):
    """Setups mamba, install packages"""

    print("\n")
    print("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")
    print(" S T E P  2   I N S T A L L   M I C R O M A M B A")
    print("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")

    if is_mamba_env_exist(install_info):
        print(f"Environment {install_info.mamba_env_name} exists. Skipping environment creation ")
        return

    # Ensure the mamba directory exists
    if not os.path.isdir(install_info.mamba_dir):
        print(f"Error: micromamba directory not found at {install_info.mamba_dir}")
        print("Please run the installation step first.")
        sys.exit(1)

    # create environment with root
    return run(f'bash {install_info.script_setup_mamba}', cwd=install_info.top_dir, shell=False, silent=False)


def step3_build_software(install_info):
    """Build additional software"""
    return run(f'bash {install_info.script_build_soft}', cwd=install_info.top_dir, shell=False, silent=False)


def main():
    """Main function to handle command line arguments and execute installation steps"""
    steps = OrderedDict()

    parser = argparse.ArgumentParser(
        description="Install micromamba environment for ML4FPGA",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )

    parser.add_argument('-s', "--step", default='all',
                        help="Name of installation step. 'all' (default) - full installation")

    parser.add_argument("--build-root", default=False, action="store_true",
                        help="Build root from sources instead of installing from mamba")

    parser.add_argument("--install-path", default=None,
                        help="Path where to install. Default is current directory")

    args = parser.parse_args()

    # Create install info with the specified path
    install_info = InstallConfig.create(args.install_path)
    install_info.print_self()

    # Define steps with the install_info parameter
    steps['gen_scripts'] = lambda: step0_generate_scripts(install_info)
    steps['install_mamba'] = lambda: step1_install_micromamba(install_info)
    steps['setup_mamba'] = lambda: step2_setup_mamba(install_info)
    steps['build_soft'] = lambda: step3_build_software(install_info)

    # This is to print argparse help
    steps_help = "Install steps (in default order):\n" + "\n".join(["   "+s for s in steps.keys()])
    parser.epilog = steps_help

    if args.step == 'all':
        for step_func in steps.values():
            step_func()
    elif args.step in steps.keys():
        steps[args.step]()
    else:
        parser.print_help()


if __name__ == "__main__":
    main()